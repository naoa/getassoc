★技術資料

全文検索用index/fullwordの内部構造のメモ

 segment は 0..31 まで, 都合 32 個しか使用できない.
 (bitmask という実装をとりあえず隠しておくことにする.)


f->flwd.ptr:
  +------------------+
  | strcut flwd_idx1 |	... segment 1
  +------------------+
  | \0               |
  +------------------+
  | text             |
  +------------------+
  | \0               |
  +------------------+
  | \377\377\377     |  --- pad
  +------------------+
  | strcut flwd_idx2 |	... segment 2
  +------------------+
  | \0               |
  +------------------+
  | text             |
  +------------------+
  | \0               |
  +------------------+
  | \377\377\377     |  --- pad
  +------------------+
  ...
 

f->idx.ptr:
  +-------------------+
  | strcut flwd_hdr   |	== f->header
  +-------------------+
  | index in flwd.ptr |  == f->idx.p
  +-------------------+
  | index in flwd.ptr |
  +-------------------+
  | index in flwd.ptr |
  +-------------------+
  ...


itb2frq が生成した .@flwd の各セグメントのヘッダ(struct flwd_idx) には
segment の情報は含まれているが, それがどの
文書に属するか(id)は記録されていない(全て0). そのかわりに,
flwd_idx の segid が 0 になると次の文書が始まることになっている.
あるセグメントがどの(WAM での)文書id に対応付けられるかは mkri 
によって計算され, その値が .@flwd の メンバ id  に埋められる.
この対応付けを助けるために, itb2frq は .@flwd と同時に
.@names というファイルを作成する.
.@names には, .@flwd の文書の名前が出現順に記録されている. これを使って
WAM での 文書ID との摺り合わせをおこなうのである(see gen_nameitbl).

一方、nwam:wam_update() が生成した @.flwd ではすでに id が記録されているので、
mkri が文書IDの摺合わせ作業をする必要はない。

.@idx は ptr_u の配列で, 各要素の
メンバ p は .@flwd のセグメント内のテキストのオフセット値を持つ
(ファイルの先頭からの).
.@idx 全体は *p をキーとして(不安定)ソートされている.
ptr_u には, その p がどの文書に属しているか, さらには
そのセグメントのヘッダがどこにあるかは記録されていない.
セグメントのヘッダを見つけるには, p からはじめて前方へ '\0'
を探すしかない(fss.c:seek_idx).

UTF32 は(UCS4 とは異なり) 21bit しか必要としない. そこで,
上位8bit にセグメント中での先頭からのオフセット(単位 == 4byte)
を記録している(255 を越えるものは全て255). fss.c:seek_idx は, 
これを利用することで高速にセグメントの先頭を発見できる.
文字を取り出す時は, 0x1fffff でマスクしなければならない(xstrcmp.c 参照).
のこり 3bit は未使用.
